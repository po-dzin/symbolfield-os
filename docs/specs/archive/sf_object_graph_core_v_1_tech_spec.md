# SF OS — Object + Graph Core v1

**Фокус:** единый объектный слой + граф как базовый орган системы. Задача канваса — зафиксировать обоснование подхода, минимальный тех-стек и ТЗ для реализации ядра.

---

## 0. Контекст и цель

SymbolField (SF) = живая символическая ОС (HUD + агенты + ритуалы + арт), которая должна:

- оставаться **суверенной** (локально-ориентированной),
- быть **расширяемой** (новые модули, новые слои смысла),
- и сохранять **целостность** при усложнении.

Для этого нужен **один стабильный слой данных**, поверх которого можно строить:

- HUD-интерфейсы,
- SymBot / агенты,
- RAG / аналитические движки,
- арт-модули (GlyphField, PulseField).

Такой слой = **объектная модель + граф связей**.

---

## 1. Обоснование подхода

### 1.1. Почему «всё есть объект»

1. Упрощение мышления и реализации:

   - единый формат хранения (JSON-документ / запись в БД),
   - один пайплайн валидации, индексации, миграций.

2. Гибкость и эволюция:

   - новые сущности (например, `ModePreset`, `AI_Agent`, `Deck`) добавляются как новые **типы**, а не отдельные таблички/миры;
   - ядро (XP, SEM7, SSA5) остаётся стабильным — расширения происходят в слое типов и связей.

3. Совместимость с любыми источниками:

   - Obsidian/Anytype/Notion/любая БЗ → всё можно привести к набору объектов с типами.

4. Ясная семантика для агентов:

   - агенту не нужно знать структуру конкретной БД; он работает с концепциями `XPLog`, `Ritual`, `Glyph`, `StateSnapshot` и т.п.

**Вывод:** объектная модель даёт *один язык для всего SF*, как для человека, так и для кода.

---

### 1.2. Почему граф как основа

1. Жизнь = связи, а не списки:

   - важен не просто факт «лог существует», а **в каком контексте**, с какими ритуалами, глифами, арками и состояниями он связан.

2. Поддержка трёх ключевых измерений SF:

   - **○ Структурное** (кто к чему относится, древо скиллов, арки, элементы XP),
   - **∣ Опытное** (какие действия реально происходят во времени, какие практики связаны с какими состояниями),
   - **• Семантическое** (какие смыслы/архетипы/концепты всплывают, как они переплетаются).

3. HUD как «линза к графу»:

   - круг стихий = агрегация по связям `XPLog → Element`,
   - таймлайн состояний = путь по `StateSnapshot` и их связям с XP/Session,
   - рекомендация ритуалов = поиск похожих узлов и часто совместно встречающихся связей.

4. Натуральная почва для RAG и агентов:

   - модель может выбирать релевантные узлы/подграфы, а не сканировать всю кучу текста;
   - легче реализовать «живую память» (журнал эволюции глифа, проекта, архетипа).

**Вывод:** граф = *орган восприятия* SF, который делает систему живой и контекстной, а не просто ещё одной БЗ.

---

## 2. Объектная модель SF (MVP-слой)

### 2.1. Общие принципы

1. Всё — объект.
2. У каждого объекта есть **type**, определяющий схему и поведение.
3. Есть чёткое разделение:
   - **событие (event)** → `XPLog`,
   - **состояние (state)** → `StateSnapshot`.
4. Связи между объектами вынесены в графовый слой, но **каждый объект знает свой Space**.

### 2.2. Базовая схема объекта

```yaml
Object:
  id: string            # UUID
  type: string          # один из зарегистрированных типов
  created_at: string    # ISO дата
  updated_at: string    # ISO дата
  space_id: string      # к какому Space относится

  title: string         # короткое имя
  body: string | null   # markdown / текст / json-поле
  tags: [string]        # быстрые ярлыки

  meta:                 # гибкий блок под разные типы
    xp:
      hp: int
      ep: int
      mp: int
      sp: int
      qp: int
    sem7_stage: string  # Seed|Focus|Draft|Commit|Expression|Insight|Release
    ssa5_layer: int     # 1..5
    source: string      # manual | symbot | api | import
```

> Примечание: часть полей (например, `xp`) может быть неактуальна для всех типов, но формат должен оставаться единым.

### 2.3. Ключевые типы объектов (ядро)

**Список типов MVP:**

- `Space` — отдельный мир (личный / проектный / комьюнити),
- `XPLog` — атомарное событие, корм для XP и статистики,
- `StateSnapshot` — слепок состояния (mode + tone + glyph + XP),
- `Ritual` — шаблон из практик / последовательность действий,
- `Skill` — узел в древе умений по XP-оси,
- `Glyph` — символьный узел (эссенция, состояние, архетип),
- `Archetype` — устойчивая роль/маска,
- `LifeArc` — длинная арка (год, сезон, проект),
- `Session` — концентрированный блок работы/практики,
- `Asset` — артефакты (арт, трек, видео, промпт).

#### Минимальные требования по содержанию

1. **Space**

   - обязательные поля: `title`, `body(optional)`;
   - хранит настройки HUD/темы/модулей для данного мира.

2. **XPLog**

   - обязательные поля: `title` (кратко действие), `meta.xp.*`, `created_at`;
   - ожидаемые связи: → `StateSnapshot`, → `Session`, → `Skill`, → `Glyph`, → `LifeArc`.

3. **StateSnapshot**

   - обязательные поля: `meta.sem7_stage (опционально)`, `meta.xp`, `body` (описание состояния), плюс поля состояния (mode, tone, glyph\_id) — могут быть в `meta`;
   - ожидаемые связи: → `XPLog`, → `Glyph`, → `Session`, → `LifeArc`.

4. **Ritual**

   - обязательные поля: `title`, `body` (структура ритуала), базовая привязка по XP/слоям SSA;
   - ожидаемые связи: → `Skill`, → `Archetype`, → `Glyph`.

5. **Skill**

   - обязательные поля: `title`, слой XP (земля/вода/огонь/воздух/qp), возможно SSA-уровень;
   - ожидаемые связи: → `XPLog`, → `Ritual`, → `Glyph`, → другие `Skill` (иерархия).

6. **Glyph**

   - обязательные поля: `title`, `body` (описание/семантика), визуальные/аудио-референсы в `meta`/через `Asset`;
   - ожидаемые связи: → `XPLog`, → `StateSnapshot`, → `Archetype`, → `LifeArc`.

7. **Archetype**

   - обязательные поля: `title`, краткое описание роли/маски;
   - ожидаемые связи: → `Ritual`, → `Glyph`, → `Skill`, → `LifeArc`.

8. **LifeArc**

   - обязательные поля: `title`, `body` (описание арки), временные границы в `meta`;
   - ожидаемые связи: → `XPLog`, → `StateSnapshot`, → `Glyph`, → `Archetype`.

9. **Session**

   - обязательные поля: `title`, временные границы, тип сессии (работа/практика/арт);
   - ожидаемые связи: → `XPLog`, → `StateSnapshot`, → `Ritual`, → `Asset`.

10. **Asset**

    - обязательные поля: `title`, ссылка/путь к файлу (локально/URL), тип (image/audio/video/text);
    - ожидаемые связи: → любой объект, где артефакт использован/создан.

---

## 3. Графовая модель SF

### 3.1. Узлы

Узел графа = любой объект SF:

- `Node = Object(id, type, meta, ...)`.

### 3.2. Рёбра (связи)

Рёбра хранятся отдельно, имеют тип и вес:

```yaml
Edge:
  from: string       # ObjectID
  to: string         # ObjectID
  type: string       # тип связи
  weight: float      # «сила» / частота
  created_at: string
```

#### Базовые типы связей (MVP)

- `belongs_to` — структурная принадлежность

  - пример: `XPLog → Session`, `Session → LifeArc`;

- `part_of` — составные элементы

  - пример: `Skill → Branch`, `Branch → Element`;

- `used_in` — объект используется внутри другого

  - пример: `Glyph → Ritual`, `Track(Asset) → Session`;

- `evolved_from` — эволюционная линия (SEM7, версии)

  - пример: `Glyph_v2 → Glyph_v1`, `Draft → Seed`;

- `tags` — концептуальная метка

  - пример: `XPLog → Archetype`, `StateSnapshot → Archetype`;

- `co_occurs_with` — часто встречаются вместе

  - пример: `Glyph_A ↔ Glyph_B`, `Skill_A ↔ Skill_B`;

- `influences` — причинное влияние

  - пример: `Ritual → StateSnapshot`, `Session → LifeArc`;

- `mirrors` — отражение/тень

  - пример: `Archetype_Light ↔ Archetype_Shadow`.

### 3.3. Три логических подграфа

1. **Структурный граф (○)**

   - типы: `Skill`, `Archetype`, `Glyph`, `LifeArc` (как структуры);
   - связи: `part_of`, `belongs_to`, `mirrors`;
   - роль: каркас системы (что вообще существует, как организовано).

2. **Опытный граф (∣)**

   - типы: `XPLog`, `Session`, `StateSnapshot`;
   - связи: `belongs_to`, `used_in`, `influences`, `co_occurs_with`;
   - роль: кровь и дыхание (что реально происходило во времени).

3. **Семантический граф (•)**

   - типы: `Archetype`, `Concept`, `Tag`, `Question` (можно добавить позже);
   - связи: `tags`, `influences`, `evolved_from`;
   - роль: поле смыслов, важное для RAG и агентов.

HUD и агенты работают с этими подграфами через разные **линзы**.

---

## 4. Минимальный тех-стек (MVP)

Цель: **быстрый, но не тупиковый** стек, который можно масштабировать.

### 4.1. Хранилище

**Вариант MVP:**

- БД: **PostgreSQL** (либо SQLite на раннем этапе, через ORM) с двумя слоями:
  - таблица `objects` (JSONB-поле для данных объекта),
  - таблица `edges` (типизированные связи).

Пример структуры:

```sql
CREATE TABLE objects (
  id UUID PRIMARY KEY,
  type TEXT NOT NULL,
  space_id UUID NOT NULL,
  created_at TIMESTAMPTZ NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL,
  title TEXT,
  body TEXT,
  tags TEXT[],
  meta JSONB
);

CREATE TABLE edges (
  id UUID PRIMARY KEY,
  from_id UUID NOT NULL,
  to_id UUID NOT NULL,
  type TEXT NOT NULL,
  weight REAL DEFAULT 1.0,
  created_at TIMESTAMPTZ NOT NULL
);
```

Дальше можно:

- либо заменить часть логики на графовую БД (Neo4j / Weaviate),
- либо держать гибрид (Postgres + отдельный графовый индекс).

### 4.2. Backend-слой

- Язык: **TypeScript (Node.js)** или **Python (FastAPI)** — на выбор.
- API-стиль: простой **REST + специальные /query-эндпоинты**.

Базовый набор эндпоинтов:

- `/objects` — CRUD для объектов;
- `/edges` — CRUD для связей;
- `/query/xp-summary` — агрегированные XP по временным окнам;
- `/query/state-timeline` — таймлайн состояний;
- `/query/graph-ego` — эго-граф вокруг объекта (N шагов);
- `/query/sem7-path` — путь эволюции объекта по SEM7.

Этот слой = единственная точка входа для HUD и агентов.

### 4.3. HUD / клиенты

- Web-клиент: **React / Next.js** (можно как отдельный фронт, можно как часть общей платформы SF HUD).
- Основная задача фронта — **не знать деталей БД**, только говорить с API.

UI-режимы, которые должен поддержать бэкенд:

- запрос мандалы XP,
- запрос таймлайна состояний,
- запрос эго-графа вокруг глифа/скилла/арки,
- запрос рекомендованных ритуалов (на основе похожих состояний).

---

## 5. ТЗ для реализации ядра (MVP)

### 5.1. Цель ТЗ

Реализовать **минимальное, но целостное ядро SF**, включающее:

- объектную модель,
- граф связей,
- базовый API для HUD и агентов.

### 5.2. Функциональные требования

1. **Объекты**

   - Реализовать создание, чтение, обновление, удаление (`CRUD`) для всех типов объектов.
   - Обеспечить валидацию по типам (минимальные обязательные поля).
   - Реализовать фильтрацию по `type`, `space_id`, диапазону дат.

2. **Связи**

   - Реализовать `CRUD` для связей (`edges`) с типами, указанными в разделе 3.2.
   - Обеспечить базовые операции:
     - получение всех связей для объекта;
     - получение эго-графа (N шагов от узла);
     - фильтрацию по типу связи.

3. **Специальные запросы (минимум для HUD)**

   - `/query/xp-summary`:

     - вход: `space_id`, временной диапазон,
     - выход: суммарные XP по осям `hp/ep/mp/sp/qp`.

   - `/query/state-timeline`:

     - вход: `space_id`, временной диапазон,
     - выход: список `StateSnapshot` по времени + связанные XP.

   - `/query/graph-ego`:

     - вход: `object_id`, глубина (N), фильтр по типам связей/узлов,
     - выход: подграф (узлы + рёбра).

   - `/query/sem7-path`:

     - вход: `object_id`,
     - выход: упорядоченный список связанных объектов/версий по `evolved_from` с указанием `sem7_stage`.

4. **Spaces**

   - Поддержать несколько `Space` (личный, проектный и т.п.).
   - Все запросы должны фильтроваться по `space_id`.

### 5.3. Нефункциональные требования

- Архитектура должна позволять:

  - замену БД без переписывания фронта и агентов;
  - добавление новых типов объектов и связей без серьёзного рефакторинга;
  - локальный деплой (на ноутбук) и облачный деплой (Vercel / любой VPS).

- Код должен быть:

  - разделён на слои: `storage` / `domain (objects+graph)` / `api`;
  - покрыт базовыми тестами на операции с объектами и графом.

### 5.4. Этапы внедрения

**Этап 1 — Data Core**

- Поднять БД.
- Реализовать таблицы `objects` и `edges`.
- Реализовать CRUD для объектов и связей.

**Этап 2 — Graph Queries**

- Реализовать эндпоинты `/query/xp-summary`, `/query/state-timeline`, `/query/graph-ego`, `/query/sem7-path`.
- Проверить на тестовых данных (несколько десятков объектов разных типов).

**Этап 3 — HUD-линк**

- Собрать простой фронт/HUD-прототип, который:
  - показывает мандалу XP за период,
  - показывает таймлайн состояний,
  - показывает эго-граф вокруг выбранного объекта.

После этого ядро можно считать **готовым к интеграции** с:

- SymBot / агентами,
- графическим модулем GlyphField,
- любыми будущими модульными надстройками SF.

